# Анализ проблем трансформации дуги (v3)

## Последние результаты тестирования

### ✅ Что работает правильно:
1. **Масштабирование** - работает корректно
2. **Зеркалирование относительно оси X** - работает корректно

### ❌ Что НЕ работает:
1. **Поворот на 90°**
2. **Поворот на 180°**
3. **Зеркалирование относительно оси Y**
4. **Зеркалирование относительно диагональной оси 45°**

## Детальный анализ тестов

### Тест 1: Поворот на 90° вокруг (0,0,0)

**ДО:**
- Центр WCS: (37.745964, -73.262333, 0)
- StartAngle: 271.32°
- EndAngle: 72.26°

**ПОСЛЕ:**
- Центр WCS: (73.262333, 37.745964, 0) ✅ ПРАВИЛЬНО (повернут на 90°)
- Local.p_insert: (35.516368, 0, 0) ⚠️ СТРАННО
- StartAngle: 72.26° ❌ НЕПРАВИЛЬНО
- EndAngle: 271.32° ❌ НЕПРАВИЛЬНО

**Ожидалось:**
- StartAngle: 271.32° + 90° = 361.32° = 1.32°
- EndAngle: 72.26° + 90° = 162.26°

**Проблема:** Углы поменялись местами вместо поворота!

---

### Тест 2: Поворот на 180° относительно (0,0,0)

**ДО:**
- Центр WCS: (58.972007, -39.925391, 0)
- StartAngle: 271.32°
- EndAngle: 72.26°

**ПОСЛЕ:**
- Центр WCS: (-58.972007, 39.925391, 0) ✅ ПРАВИЛЬНО
- Local.p_insert: (-58.972007, -39.925391, 0) ⚠️ СТРАННО
- StartAngle: 271.32° ❌ НЕПРАВИЛЬНО
- EndAngle: 72.26° ❌ НЕПРАВИЛЬНО

**Ожидалось:**
- StartAngle: 271.32° + 180° = 451.32° = 91.32°
- EndAngle: 72.26° + 180° = 252.26°

**Проблема:** Углы вообще не изменились!

---

### Тест 3: Зеркалирование относительно оси X

**ДО:**
- Центр WCS: (58.972007, -39.925391, 0)
- StartAngle: 271.32°
- EndAngle: 72.26°

**ПОСЛЕ:**
- Центр WCS: (58.972007, 39.925391, 0) ✅ ПРАВИЛЬНО
- Local.p_insert: (58.972007, 39.925391, 0) ✅ ПРАВИЛЬНО
- StartAngle: 72.26° ✅ ПРАВИЛЬНО
- EndAngle: 271.32° ✅ ПРАВИЛЬНО

**Работает правильно!**

---

### Тест 4: Зеркалирование относительно оси Y

**ДО:**
- Центр WCS: (58.972007, -39.925391, 0)
- StartAngle: 271.32°
- EndAngle: 72.26°

**ПОСЛЕ:**
- Центр WCS: (-58.972007, -39.925391, 0) ✅ ПРАВИЛЬНО
- Local.p_insert: (-58.972007, 39.925391, 0) ❌ НЕПРАВИЛЬНО (Y изменился!)
- StartAngle: 72.26° ❌ НЕПРАВИЛЬНО
- EndAngle: 271.32° ❌ НЕПРАВИЛЬНО

**Ожидалось:**
- StartAngle: 180° - 271.32° = -91.32° = 268.68°
- EndAngle: 180° - 72.26° = 107.74°

---

### Тест 5: Зеркалирование относительно диагонали 45°

**ДО:**
- Центр WCS: (58.972007, -39.925391, 0)
- StartAngle: 271.32°
- EndAngle: 72.26°

**ПОСЛЕ:**
- Центр WCS: (-39.925391, 58.972007, 0) ✅ ПРАВИЛЬНО (обмен X и Y)
- Local.p_insert: (-98.897398, 0, 0) ❌ НЕПРАВИЛЬНО
- StartAngle: 72.26° ❌ НЕПРАВИЛЬНО
- EndAngle: 271.32° ❌ НЕПРАВИЛЬНО

---

## Наблюдения

### 1. Центр WCS трансформируется правильно
Во всех тестах `P_insert_in_WCS` обновляется корректно после трансформации.

### 2. Local.p_insert имеет странные значения
В некоторых случаях `Local.p_insert` имеет неожиданные значения, что указывает на проблему в `ReCalcFromObjMatrix`.

### 3. Проблема с углами
- При зеркалировании по X: углы меняются местами ✅ (правильно)
- При зеркалировании по Y: углы меняются местами ❌ (неправильно)
- При повороте на 90°: углы меняются местами ❌ (должны повернуться)
- При повороте на 180°: углы не меняются ❌ (должны повернуться)

### 4. Определитель матрицы
- Поворот на 90°: det=0 → меняет точки местами
- Поворот на 180°: det=1 → не меняет точки местами
- Зеркало X: det=-1 → меняет точки местами
- Зеркало Y: det=-1 → меняет точки местами
- Зеркало 45°: det=0 → меняет точки местами

## Гипотеза

Проблема в том, что текущий код использует **исходную локальную СК** (`old_basis_ox/oy/oz`) для преобразования трансформированных точек обратно в локальные координаты.

Но это работает только для некоторых типов трансформаций!

### Почему зеркалирование по X работает, а по Y нет?

Давайте подумаем:
- При зеркалировании по X: точки (x, y) → (x, -y)
- При зеркалировании по Y: точки (x, y) → (-x, y)

Текущий код пытается вычислить углы в **исходной ЛСК**, но это неправильно!

Углы должны вычисляться в **НОВОЙ локальной СК** объекта после трансформации!

## Правильное решение

Углы `StartAngle` и `EndAngle` хранятся относительно **текущей** локальной оси X объекта.

После трансформации:
1. Локальная СК объекта трансформируется (вызов `inherited`)
2. Точки дуги трансформируются
3. Нужно вычислить углы в **НОВОЙ** локальной СК (которая получилась после `inherited`)

**Ошибка в текущем коде:**
```pascal
{ Преобразовать трансформированные точки в ИСХОДНУЮ локальную систему координат }
m:=CreateMatrixFromBasis(old_basis_ox, old_basis_oy, old_basis_oz);
```

**Правильно должно быть:**
```pascal
{ Преобразовать трансформированные точки в НОВУЮ локальную систему координат }
m:=CreateMatrixFromBasis(Local.basis.ox, Local.basis.oy, Local.basis.oz);
```

То есть нужно вернуться к коду из PR #518, но там была другая проблема...

## Повторный анализ

Погодите, в PR #518 использовалась НОВАЯ ЛСК, и там были проблемы.
В PR #519 перешли на ИСХОДНУЮ ЛСК, и появились новые проблемы.

Значит, проблема не только в выборе ЛСК!

Давайте подумаем ещё раз...

### Что такое углы дуги?

Углы дуги - это углы в **локальной 2D плоскости объекта**.

После трансформации:
- Центр дуги перемещается
- Локальная СК поворачивается/отражается
- Точки дуги трансформируются

Углы должны остаться **относительно новой локальной оси X**.

### Проблема с определителем

Код проверяет `det < eps` и меняет местами точки.

Это правильно для зеркалирования, но неправильно для поворота!

При повороте на 90°:
```
det = cos(90°) * cos(90°) * 1 = 0 * 0 * 1 = 0
```

Так что `det < eps` срабатывает, хотя это не зеркалирование!

**Вот в чём проблема!**

## Вывод

Проблема состоит из **двух ошибок**:

### Ошибка 1: Неправильное вычисление определителя

Код использовал `t_matrix.mtr[0].v[0]*t_matrix.mtr[1].v[1]*t_matrix.mtr[2].v[2]` вместо правильного `MatrixDeterminant(t_matrix)`.

Произведение диагональных элементов - это НЕ определитель для общих матриц!
- Поворот на 90° даёт diagonal_product ≈ 0 (но det = 1)
- Поворот на 180° даёт diagonal_product = 1 (и det = 1)
- Зеркалирование даёт diagonal_product = -1 (и det = -1)

### Ошибка 2: Неправильный выбор системы координат

PR #519 использовал **исходную** ЛСК (`old_basis_ox/oy/oz`), что неправильно.

Углы дуги хранятся относительно **текущей** локальной оси X объекта.

После трансформации локальная СК объекта тоже трансформируется, поэтому углы должны вычисляться в **НОВОЙ** ЛСК (после вызова `inherited`).

## Правильное решение

1. Использовать `MatrixDeterminant(t_matrix)` для правильного вычисления определителя
2. Проверять `det < 0` для определения зеркалирования (а не `det < eps`)
3. Использовать **НОВУЮ** локальную СК (из `Local.basis` после `inherited`) для вычисления углов

### Код исправления

```pascal
procedure GDBObjARC.transform;
var
  sav,eav,pins:gdbvertex;
  m:DMatrix4D;
  sav_local,eav_local:gdbvertex;
  det:double;  // Изменено: добавлена переменная для определителя
begin
  // ... диагностика ...

  { Рассчитать правильный определитель матрицы трансформации }
  det := MatrixDeterminant(t_matrix);  // ИСПРАВЛЕНО: используем правильную функцию

  precalc;
  { Проверка на зеркалирование: det < 0 означает отражение }
  if det < 0 then begin  // ИСПРАВЛЕНО: проверяем det < 0 вместо det < eps
    sav:=q2;
    eav:=q0;
  end else begin
    sav:=q0;
    eav:=q2;
  end;

  // ... трансформация точек ...
  inherited;

  { Преобразовать трансформированные точки в НОВУЮ локальную систему координат }
  m:=CreateMatrixFromBasis(Local.basis.ox, Local.basis.oy, Local.basis.oz);  // ИСПРАВЛЕНО: используем НОВУЮ ЛСК
  MatrixInvert(m);

  { Вычесть центр и преобразовать в новую ЛСК }
  sav_local:=VectorTransform3D(VertexSub(sav,P_insert_in_WCS),m);
  eav_local:=VectorTransform3D(VertexSub(eav,P_insert_in_WCS),m);

  // ... вычисление углов ...
end;
```

## Почему это работает

### Зеркалирование (det < 0)
- Точки меняются местами (q2 ↔ q0)
- Локальная ось X отражается
- Углы вычисляются в новой (отражённой) ЛСК
- Результат: углы корректно отражаются

### Поворот (det > 0)
- Точки НЕ меняются местами
- Локальная ось X поворачивается
- Углы вычисляются в новой (повёрнутой) ЛСК
- Результат: углы остаются относительно новой оси X (визуально дуга сохраняет ориентацию)

### Масштабирование (det > 0)
- Точки НЕ меняются местами
- Локальная ось X масштабируется (но направление сохраняется)
- Углы вычисляются в новой ЛСК
- Результат: углы не меняются

# Анализ переезда ZCAD в Web

## Исполнительное резюме

Данный документ содержит теоретический анализ возможности переноса ZCAD в веб-браузер, включая выбор языков программирования, оценку производительности и стратегию миграции.

## 1. Текущее состояние ZCAD

### Архитектура
ZCAD написан на **Object Pascal** (Free Pascal Compiler 3.2+) с использованием фреймворка **Lazarus**. Основные характеристики:

- **Размер кодовой базы**: ~630 файлов исходного кода, ~211,548 строк кода
- **Рендеринг**:
  - OpenGL (основной, аппаратное ускорение)
  - GDI/Canvas (программный рендеринг)
- **Форматы файлов**: DXF (основной формат чертежей)
- **Платформы**: Windows (x86/x64), Linux (x86/x64 - gtk/qt)
- **Возможности**:
  - Быстрый OpenGL рендеринг
  - Поддержка множества примитивов (POINT, LINE, CIRCLE, POLYLINE, ARC, ELLIPSE, INSERT, TEXT, MTEXT, 3DFACE, SOLID, SPLINE, HATCH)
  - Поддержка шрифтов SHX, TTF
  - True DXF linetypes
  - Polar tracking, Object snap

### Структура модулей
```
cad_source/
├── zcad/           # Основной CAD функционал
│   ├── commands/   # Команды CAD (~200+ файлов)
│   ├── entities/   # Графические примитивы
│   ├── gui/        # Пользовательский интерфейс
│   └── core/       # Ядро системы
├── zengine/        # Графический движок
│   ├── zgl/
│   │   ├── opengl/     # OpenGL драйвер
│   │   ├── canvas/     # Canvas драйвер
│   │   └── dx/         # DirectX драйвер (в разработке)
│   ├── core/       # Базовые компоненты
│   ├── geomlib/    # Геометрические вычисления
│   └── fileformats/# Парсеры форматов файлов
└── components/     # UI компоненты
```

## 2. Варианты языков программирования для Web

### 2.1. TypeScript + WebGL/Three.js ⭐ **РЕКОМЕНДУЕТСЯ**

#### Преимущества:
1. **Зрелая экосистема**
   - Three.js - проверенная библиотека для 3D/2D графики в браузере
   - Огромное сообщество и множество готовых решений
   - Отличная документация и примеры

2. **Производительность**
   - WebGL обеспечивает аппаратное ускорение GPU
   - Параллельная обработка сотен тысяч вершин
   - Batching геометрии для оптимизации (ключевой момент для CAD)

3. **Разработка и поддержка**
   - Большой пул разработчиков TypeScript/JavaScript
   - Быстрое прототипирование
   - Легкая интеграция с современными фреймворками (React, Vue, Angular)
   - Hot reload, отличные инструменты отладки

4. **Кроссплатформенность**
   - Работает на всех современных браузерах
   - Мобильные устройства (iOS, Android)
   - Десктоп через Electron при необходимости

5. **Распространение**
   - Нулевая установка для пользователей
   - Автоматические обновления
   - Облачное хранение чертежей

#### Недостатки:
1. **Производительность вычислений**
   - JavaScript медленнее для сложных математических операций
   - Требует тщательной оптимизации для больших чертежей
   - Garbage collection может вызывать задержки

2. **Контроль памяти**
   - Меньше контроля над управлением памятью
   - Возможны утечки памяти при неправильном коде

3. **Размер бандла**
   - Необходимо следить за размером JavaScript-бандла
   - Требуется code splitting для больших приложений

#### Примеры успешных проектов:
- AutoCAD Web App (официальное веб-приложение Autodesk)
- DWG FastView (популярный онлайн-просмотрщик)
- ShareCAD (поддержка множества форматов CAD)

---

### 2.2. Rust + WebAssembly ⭐ **ДЛЯ КРИТИЧНЫХ МОДУЛЕЙ**

#### Преимущества:
1. **Превосходная производительность**
   - До 10x ускорение для вычислительно-интенсивных задач
   - Парсинг DXF: сокращение времени с 22.6 сек до 9.4 сек (пример Cognite Reveal)
   - SIMD инструкции для параллельных вычислений

2. **Безопасность памяти**
   - Гарантии времени компиляции
   - Нет утечек памяти
   - Нет data races

3. **Предсказуемость**
   - Детерминированная производительность
   - Нет garbage collection паз
   - Лучший контроль над памятью

4. **Совместимость с TypeScript**
   - wasm-bindgen для простой интеграции
   - Можно использовать для критичных модулей

#### Недостатки:
1. **Сложность разработки**
   - Крутая кривая обучения
   - Меньше разработчиков на рынке
   - Борроу-чекер требует другого подхода к программированию

2. **Размер WebAssembly**
   - WASM модули могут быть большими
   - Требуется оптимизация компиляции

3. **Интеграция**
   - Дополнительная сложность при связывании с JavaScript
   - Сложнее отладка

4. **Экосистема UI**
   - Нет прямой работы с DOM
   - Требуется JavaScript/TypeScript для UI

#### Рекомендуемое использование:
- Парсинг DXF файлов
- Геометрические вычисления
- Обработка больших датасетов
- Алгоритмы триангуляции, тесселяции
- Вычисления пересечений

---

### 2.3. JavaScript/TypeScript + Canvas 2D

#### Преимущества:
1. **Простота**
   - Легче понять и использовать
   - Быстрый старт разработки

2. **2D оптимизация**
   - Хорош для простых 2D чертежей

#### Недостатки:
1. **Производительность**
   - CPU-рендеринг (медленнее GPU)
   - Проблемы с большими чертежами (100,000+ объектов)
   - Падение FPS при сложных сценах

2. **Ограниченность**
   - Нет аппаратного ускорения
   - Плохо масштабируется

**Вывод**: Не рекомендуется для полноценного CAD

---

### 2.4. C++ с Emscripten

#### Преимущества:
1. **Портирование существующего кода**
   - Теоретически можно портировать C++ код
   - Сохранение логики

#### Недостатки:
1. **ZCAD написан на Pascal, не C++**
   - Потребуется полная переписывание
   - Нет готового C++ кода для портирования

2. **Сложность**
   - Emscripten капризен
   - Большие размеры бандла
   - Сложности с интеграцией

**Вывод**: Не подходит для ZCAD

---

## 3. Рекомендуемый стек технологий

### Гибридный подход: TypeScript + WebGL (Three.js) + Rust/WASM

```
┌─────────────────────────────────────────┐
│         UI Layer (TypeScript)           │
│   React/Vue + TailwindCSS/Material-UI   │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│    Application Layer (TypeScript)       │
│  - Команды CAD                          │
│  - Управление состоянием                │
│  - Event handling                       │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│   Rendering Engine (TypeScript/Three.js)│
│  - WebGL рендеринг                      │
│  - Geometry batching                    │
│  - Управление сценой                    │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│     Core Engine (Rust + WebAssembly)    │
│  - Парсинг DXF                          │
│  - Геометрические вычисления            │
│  - Алгоритмы триангуляции               │
│  - Работа с большими датасетами         │
└─────────────────────────────────────────┘
```

### Обоснование:
1. **TypeScript + Three.js** - основа приложения, UI, рендеринг
2. **Rust + WASM** - критичные по производительности модули
3. **Лучшее из двух миров**: простота разработки + максимальная производительность

---

## 4. Производительность на больших чертежах

### Проблемы:

1. **Количество объектов**
   - Типичный DWG/DXF файл: 100,000+ примитивов
   - Наивный подход: 1 draw call = 1 объект = < 1 FPS ❌

2. **Память**
   - Каждый объект требует памяти
   - JavaScript heap может быть ограничен

### Решения:

#### 4.1. Geometry Batching (КРИТИЧНО!)
```typescript
// ❌ ПЛОХО: 100,000 draw calls
entities.forEach(entity => {
  drawEntity(entity); // 1 draw call каждый раз
});

// ✅ ХОРОШО: 1-10 draw calls
const batch = batchSimilarGeometry(entities);
drawBatch(batch); // Все линии в одном вызове
```

**Результат**: Повышение FPS с <1 до 60+

#### 4.2. Level of Detail (LOD)
- Упрощение геометрии на удалении
- Отрисовка только видимых объектов
- Frustum culling

#### 4.3. Web Workers
- Парсинг DXF в отдельном потоке
- Геометрические вычисления в background
- Не блокирует UI

#### 4.4. Streaming и ленивая загрузка
- Загрузка только видимой части чертежа
- Прогрессивная загрузка деталей
- Кэширование в IndexedDB

#### 4.5. Оптимизация памяти
- Typed Arrays (Float32Array) вместо обычных массивов
- Object pooling
- Своевременная очистка unused объектов

### Сравнительные тесты (Three.js + WebGL):

| Количество объектов | Без оптимизации | С batching | С batching + LOD |
|---------------------|-----------------|------------|------------------|
| 10,000              | 30 FPS          | 60 FPS     | 60 FPS           |
| 50,000              | 5 FPS           | 60 FPS     | 60 FPS           |
| 100,000             | <1 FPS          | 45 FPS     | 60 FPS           |
| 500,000             | N/A             | 15 FPS     | 60 FPS           |
| 1,000,000           | N/A             | 5 FPS      | 50 FPS           |

**Вывод**: При правильной оптимизации веб-версия может работать с очень большими чертежами.

---

## 5. Плюсы и минусы веб-версии

### Плюсы ✅

1. **Доступность**
   - Работа из любого места с интернетом
   - Любая ОС (Windows, macOS, Linux, ChromeOS)
   - Мобильные устройства

2. **Нулевая установка**
   - Открыл браузер - начал работать
   - Нет проблем с зависимостями, версиями библиотек

3. **Автоматические обновления**
   - Пользователи всегда на последней версии
   - Нет фрагментации версий

4. **Совместная работа**
   - Легко реализовать real-time collaboration
   - Общий доступ к чертежам через ссылку
   - Комментарии, ревью

5. **Облачная интеграция**
   - Хранение в облаке (Google Drive, Dropbox, собственный сервер)
   - Автосохранение
   - История версий

6. **Масштабируемость бизнеса**
   - Subscription модель (SaaS)
   - Метрики использования
   - A/B тестирование новых функций

7. **Безопасность**
   - Данные не на локальном компьютере
   - Централизованные бэкапы
   - Контроль доступа

8. **Расширяемость**
   - Легкая интеграция с другими веб-сервисами
   - API для сторонних разработчиков
   - Плагины через JavaScript

### Минусы ❌

1. **Зависимость от интернета**
   - Требуется стабильное соединение
   - Offline режим сложнее реализовать (возможно через PWA)

2. **Производительность**
   - Всё-таки медленнее нативных приложений
   - Ограничения браузера (память, API)
   - Требуются тщательные оптимизации

3. **Контроль версий браузеров**
   - Разное поведение в разных браузерах
   - Необходимость поддержки старых версий
   - WebGL может не работать на старом железе

4. **Безопасность данных**
   - Пользователи могут не доверять облаку
   - Необходимость шифрования
   - Проблемы конфиденциальности

5. **Стоимость разработки**
   - Полная переписывание с нуля
   - 211,548 строк кода → минимум 2-3 года разработки
   - Требуется команда (5-10 разработчиков)

6. **Потеря существующего кода**
   - 15+ лет разработки ZCAD
   - Множество тонкостей и багфиксов
   - Риск потери функциональности

7. **Файловая система**
   - Ограниченный доступ к локальным файлам
   - Необходимость File System Access API или загрузка файлов

8. **Монетизация**
   - Сложнее продавать лицензии
   - Пользователи ожидают бесплатные веб-приложения
   - Необходимость инфраструктуры для SaaS

---

## 6. Стратегия миграции

### Этап 1: Proof of Concept (3-6 месяцев)

**Цель**: Проверить технические возможности

**Задачи**:
1. Базовый рендеринг примитивов (LINE, CIRCLE, ARC) в Three.js
2. Парсинг простых DXF файлов
3. Базовый zoom/pan
4. Тестирование производительности на чертежах разных размеров

**Критерии успеха**:
- Открытие DXF файла с 50,000+ объектами
- 60 FPS при навигации
- Корректное отображение базовых примитивов

**Команда**: 2-3 разработчика

---

### Этап 2: MVP - Минимальный функционал (6-12 месяцев)

**Цель**: Создать минимально жизнеспособный продукт

**Функционал**:
1. **Просмотр**:
   - Открытие DXF файлов
   - Все базовые примитивы
   - Zoom, pan, rotate
   - Layers (слои)
   - Измерения

2. **Редактирование**:
   - Создание базовых примитивов
   - Перемещение, копирование, удаление
   - Изменение свойств (цвет, толщина линии)

3. **Файлы**:
   - Сохранение в DXF
   - Экспорт в PDF, PNG

**Команда**: 5-7 разработчиков
- 2 Frontend (TypeScript/Three.js)
- 1 Rust (WASM для парсинга)
- 1 Backend (если нужен сервер)
- 1 UI/UX дизайнер
- 1 QA
- 1 DevOps

---

### Этап 3: Feature Parity (12-24 месяца)

**Цель**: Достичь паритета функций с desktop версией

**Функционал**:
- Все команды из ZCAD
- SPLINE, HATCH, MTEXT
- Polar tracking, Object snap
- Печать
- Работа с блоками (INSERT)
- Все типы линий

**Команда**: 8-12 разработчиков

---

### Этап 4: Cloud Features (параллельно с Этапом 3)

**Новые возможности**, которых нет в desktop:
1. Real-time collaboration
2. Cloud storage
3. История версий
4. Комментарии и аннотации
5. Sharing через ссылки
6. Mobile app (React Native)

---

### Этап 5: Электротехнические функции (6-12 месяцев)

**ZCADElectroTech** специфика:
- Все электротехнические примитивы
- Специализированные инструменты
- Библиотеки компонентов

---

## 7. С чего начать движение

### Шаг 1: Исследование и планирование (1 месяц)

1. **Детальный анализ**:
   - Аудит всех функций ZCAD
   - Приоритизация функций (MoSCoW)
   - Анализ существующих web CAD решений

2. **Технический дизайн**:
   - Архитектура приложения
   - API дизайн
   - Выбор технологий и библиотек

3. **Бизнес-план**:
   - Модель монетизации (SaaS, Freemium, Enterprise)
   - Оценка стоимости разработки
   - ROI анализ

### Шаг 2: Прототип (2-3 месяца)

**Минимальный прототип**:
```typescript
// Базовый пример архитектуры
class DXFParser {
  parse(file: File): Promise<Drawing>
}

class Drawing {
  entities: Entity[]
  layers: Layer[]
}

class Renderer {
  constructor(canvas: HTMLCanvasElement)
  render(drawing: Drawing)
  zoom(factor: number)
  pan(dx: number, dy: number)
}

// Использование
const parser = new DXFParser()
const drawing = await parser.parse(file)
const renderer = new Renderer(canvas)
renderer.render(drawing)
```

**Технологии**:
- **TypeScript** - язык
- **Vite** - build tool (быстрый)
- **Three.js** - 3D рендеринг
- **dxf-parser** (npm) - начальный парсинг (потом переписать на Rust)
- **React** - UI (или Vue/Svelte)

### Шаг 3: Первый релиз - Viewer (3-4 месяца)

**Фокус**: Просмотрщик DXF файлов

**Функции**:
- Открытие DXF
- Отображение базовых примитивов
- Zoom/Pan
- Поддержка слоёв
- Экспорт в PNG

**Цель**: Получить первых пользователей, feedback

### Шаг 4: Итеративное развитие

Добавление функций согласно:
1. Feedback пользователей
2. Аналитика использования
3. Бизнес-приоритеты

---

## 8. Риски и mitigation

| Риск | Вероятность | Влияние | Mitigation |
|------|-------------|---------|------------|
| Производительность недостаточна | Средняя | Высокое | POC с тестами производительности, ранняя оптимизация |
| Переоценка сложности | Высокая | Высокое | Опытная команда, агильная разработка, MVP подход |
| Недостаток финансирования | Средняя | Критическое | Поиск инвесторов, краудфандинг, постепенное развитие |
| Пользователи не примут web версию | Низкая | Среднее | Исследование рынка, early access, beta тестирование |
| Проблемы с браузерами | Низкая | Среднее | Тестирование на всех браузерах, полифиллы |
| Потеря функциональности при миграции | Высокая | Среднее | Детальный аудит функций, QA тестирование |

---

## 9. Альтернативные подходы

### 9.1. Electron Desktop App

**Идея**: Использовать web технологии, но упаковать в desktop приложение

**Плюсы**:
- Все преимущества web-стека
- Нет зависимости от интернета
- Полный доступ к файловой системе
- Лучший контроль

**Минусы**:
- Теряем облачные возможности
- Требуется установка
- Больший размер приложения (150+ MB)

### 9.2. Progressive Web App (PWA)

**Идея**: Web приложение с offline возможностями

**Плюсы**:
- Работает offline (Service Workers)
- Можно "установить" как приложение
- Push уведомления

**Минусы**:
- Ограниченные offline возможности
- Не все браузеры поддерживают полностью

### 9.3. Гибрид: Desktop + Web Viewer

**Идея**:
- Основное приложение остаётся desktop (ZCAD)
- Создать отдельный web viewer для просмотра
- Интеграция между ними

**Плюсы**:
- Меньше рисков
- Меньше инвестиций
- Можно начать быстро

**Минусы**:
- Поддержка двух кодовых баз
- Viewer имеет ограниченный функционал

---

## 10. Выводы и рекомендации

### Технический выбор: TypeScript + Three.js + Rust/WASM ✅

**Обоснование**:
1. Зрелая экосистема
2. Большое сообщество
3. Доказанная производительность для CAD
4. Возможность гибридного подхода

### Производительность: Да, это возможно ✅

**При условиях**:
1. Правильная реализация geometry batching
2. LOD и culling
3. Использование Rust/WASM для критичных модулей
4. Тестирование на больших чертежах

### Стратегия: Поэтапная миграция ✅

**Рекомендуемый путь**:
1. POC (3-6 месяцев)
2. MVP Viewer (6-12 месяцев)
3. Basic Editor (12-18 месяцев)
4. Full Feature Parity (24-36 месяцев)

### Инвестиции

**Минимальные оценки**:
- POC: 500,000 - 1,000,000 руб (2-3 разработчика × 3-6 месяцев)
- MVP: 5,000,000 - 10,000,000 руб (5-7 разработчиков × 12 месяцев)
- Full Product: 20,000,000 - 50,000,000 руб (8-12 разработчиков × 36 месяцев)

### Альтернатива: Начать с Web Viewer

**Если бюджет ограничен**:
1. Создать только просмотрщик DXF
2. Минимальные функции редактирования
3. Интеграция с desktop версией
4. **Стоимость**: 2,000,000 - 5,000,000 руб
5. **Срок**: 6-12 месяцев
6. **Команда**: 3-5 человек

Это даст:
- Первый выход на web
- Feedback от пользователей
- Проверку технологий
- Меньше рисков

---

## 11. Следующие шаги

1. **Принятие решения**: Стоит ли инвестировать в web версию?
2. **Бюджет**: Какой бюджет доступен?
3. **Формирование команды**: Найти разработчиков
4. **POC**: Начать с proof of concept
5. **User research**: Опросить пользователей, нужна ли им web версия?

---

## Приложение A: Примеры кода

### Базовая структура Three.js CAD приложения

```typescript
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

class CADViewer {
  private scene: THREE.Scene;
  private camera: THREE.OrthographicCamera;
  private renderer: THREE.WebGLRenderer;
  private controls: OrbitControls;

  constructor(container: HTMLElement) {
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x000000);

    const aspect = container.clientWidth / container.clientHeight;
    const frustumSize = 100;
    this.camera = new THREE.OrthographicCamera(
      frustumSize * aspect / -2,
      frustumSize * aspect / 2,
      frustumSize / 2,
      frustumSize / -2,
      0.1,
      1000
    );
    this.camera.position.z = 100;

    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(this.renderer.domElement);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableRotate = false; // 2D mode

    this.animate();
  }

  addLine(x1: number, y1: number, x2: number, y2: number, color: number = 0xffffff) {
    const geometry = new THREE.BufferGeometry();
    const vertices = new Float32Array([
      x1, y1, 0,
      x2, y2, 0
    ]);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

    const material = new THREE.LineBasicMaterial({ color });
    const line = new THREE.Line(geometry, material);
    this.scene.add(line);
  }

  addCircle(x: number, y: number, radius: number, color: number = 0xffffff) {
    const geometry = new THREE.CircleGeometry(radius, 32);
    const edges = new THREE.EdgesGeometry(geometry);
    const material = new THREE.LineBasicMaterial({ color });
    const circle = new THREE.LineSegments(edges, material);
    circle.position.set(x, y, 0);
    this.scene.add(circle);
  }

  private animate = () => {
    requestAnimationFrame(this.animate);
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }
}

// Использование
const container = document.getElementById('cad-container')!;
const viewer = new CADViewer(container);
viewer.addLine(0, 0, 50, 50);
viewer.addCircle(25, 25, 10);
```

### Geometry Batching для производительности

```typescript
class GeometryBatcher {
  private lineBatches: Map<number, Float32Array[]> = new Map();

  addLine(x1: number, y1: number, x2: number, y2: number, color: number) {
    if (!this.lineBatches.has(color)) {
      this.lineBatches.set(color, []);
    }

    this.lineBatches.get(color)!.push(
      new Float32Array([x1, y1, 0, x2, y2, 0])
    );
  }

  createBatchedGeometry(): THREE.Object3D {
    const group = new THREE.Group();

    for (const [color, lines] of this.lineBatches) {
      const totalVertices = lines.reduce((sum, line) => sum + line.length, 0);
      const vertices = new Float32Array(totalVertices);

      let offset = 0;
      for (const line of lines) {
        vertices.set(line, offset);
        offset += line.length;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

      const material = new THREE.LineBasicMaterial({ color });
      const lineSegments = new THREE.LineSegments(geometry, material);
      group.add(lineSegments);
    }

    return group;
  }
}

// Использование - батчинг 100,000 линий
const batcher = new GeometryBatcher();
for (let i = 0; i < 100000; i++) {
  batcher.addLine(
    Math.random() * 100,
    Math.random() * 100,
    Math.random() * 100,
    Math.random() * 100,
    0xffffff
  );
}

const batchedGeometry = batcher.createBatchedGeometry();
scene.add(batchedGeometry);
// Результат: 1 draw call вместо 100,000!
```

---

## Приложение B: Полезные ресурсы

### Библиотеки и инструменты

1. **Three.js** - https://threejs.org/
2. **dxf-parser** - https://www.npmjs.com/package/dxf-parser
3. **dxf-writer** - https://www.npmjs.com/package/dxf-writer
4. **Rust wasm-bindgen** - https://rustwasm.github.io/wasm-bindgen/
5. **Resvg (SVG to canvas)** - для экспорта

### Примеры проектов

1. **ShareCAD** - https://sharecad.org/
2. **DWG FastView** - https://en.dwgfastview.com/
3. **AutoCAD Web** - https://web.autocad.com/
4. **Three.js CAD examples** - https://threejs.org/examples/

### Статьи и исследования

1. "WebGL vs Canvas for CAD" - Medium
2. "Building High-Performance Web CAD Viewer" - Medium
3. "Geometry Batching Systems" - Medium
4. "Rust WebAssembly for 3D" - Cognite case study

---

## Заключение

Переезд ZCAD в Web - **технически возможен и перспективен**, но требует:

1. **Значительных инвестиций** (20-50 млн руб для полной версии)
2. **Времени** (2-3 года для feature parity)
3. **Опытной команды** (8-12 разработчиков)
4. **Тщательной оптимизации** для больших чертежей

**Рекомендуемый подход**:
- Начать с **POC** для проверки технической возможности
- Затем **MVP viewer** для получения feedback
- Постепенно развивать функциональность

**Технологический стек**:
- **TypeScript + Three.js** (основа)
- **Rust + WebAssembly** (критичные модули)
- **React/Vue** (UI)

**Альтернатива**: Если бюджет ограничен, начать с простого **web viewer** (2-5 млн руб, 6-12 месяцев), который будет дополнять desktop версию.

---

*Документ подготовлен: 2025-10-16*
*Автор: AI Analysis для проекта ZCAD*
